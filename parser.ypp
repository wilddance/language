%{
    #include<stdio.h>
    #include<stdlib.h>
    #include<string>
    #include<string.h>
    #include<vector>
    #include"../classes/Vars.cpp"
    #include"../defs.h"

    //#ifndef FLEX_DEBUG printf(...) printf("")
        
    ///////////////
    // Bison/flex stuff
    ///////////////

    int yyerror(const char*);
    int yylex();
    extern int yylineno;     //i declare yylineno from the lexical analyzer
    extern char *yytext;
    extern char * yytext;

    ///////////////
    // Custom part
    ///////////////
    Vars v;

    int line = 0;
    char buff[100];
    string s;

    vector<string> lines;

    void nextLine(){
        s = string(buff);
        lines.push_back(s);
        printf("%d. %s\n", lines.size(), buff);
        memset(buff, 0, 100);
    }

    void nextLine(const char* ins){
        sprintf(buff, "%s", ins);
        nextLine();
    }

    void sub(){
        nextLine("SUB");
    }

    // TODO: parameter
    void jlz(){
        nextLine("JLZ");
    }

    void push(char* name){
        sprintf(buff, "PUSH $ %d", v.get(name)) ;
        nextLine();
    }

    void pop(char* name){
        sprintf(buff, "POP $%d", v.get(name) );
        nextLine();
    }
    
    // debug method only
    void debug(){
        puts("Code:");
        for(int i = 0; i < lines.size();i++){
            puts(lines[i].c_str());
        }        
    }
%}

%union{
    int val;
    char ch;
    char* s;
}

%token IF
%token REL_OPER
%token IDENT 
%token OPER
%token DIGITS
%token COM
%token READ
%token END
%token BOOL_VAL

%token STARTBLOCK
%token ENDBLOCK

%type<int> REL_OPER bool
%type<val> exp DIGITS value
%type<ch> OPER 
%type<s> IDENT BOOL_VAL
%type<s> READ END 
%type<ch> STARTBLOCK ENDBLOCK


%%

s: 
 | s read | s value | s end | s if | s bool

value: exp { printf("Value: %d\n", $$); }
read: READ IDENT{ sprintf(buff, "READ $%d", v.get(std::string($2))); nextLine(); }
end: END {end();}
    
///////////////// 
// Boolean stuff
/////////////////
if: IF bool {}


bool: IDENT REL_OPER IDENT{ 
    printf("Wyra≈ºenie Bool\n");  

    printf("$1 = %s\n", $1);

    printf("$3 = %s\n", $3);
    push($1);
    push($3);
    jlz();
} | BOOL_VAL  

i: IDENT {}


// block: STARTBLOCK ENDBLOCK { puts("Blok"); }
// bool: bool_exp BOOL_OPER bool_exp {  }

/////////////////
// Standard number operations
/////////////////
exp: exp OPER DIGITS {

    puts("Mamy expr!");
    /*
    printf("$1 = %d\n", $1);
    printf("$2 = %c\n", $2);
    printf("$3 = %d\n", $3);
    */

    $$ = $1 + $3;
    switch($2){
        case '+':
            $$ = $1 + $3; break;
        case '-':
            $$ = $1 - $3; break;
        case '*':
            $$ = $1 * $3; break;
        case '/':
            $$ = $1 / $3; break;
    }
} | DIGITS | '(' exp ')'

%%

/*

line:  DIGITS { printf("LICZBA %d", $$); } | 
DIGITS PLUS { printf("LICXZBA z plusem %d", $$); }
        | COM {printf("Dupa");}


int yyerror(const char* s) {
	fprintf(stderr, "Parse error for token: %s\n", s);
	exit(1);
}

*/
int yyerror (const char *msg) {
  printf("oha, %s: text: '%s' val: %s in line %d\n", msg, yytext, yylval, yylineno);
  return 0;
}

int main() {
        printf("Zaczynamy parsowanie\n");
		yyparse();
}
